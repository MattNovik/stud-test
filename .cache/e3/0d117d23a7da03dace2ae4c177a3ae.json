{"id":"ma5Y","dependencies":[{"name":"C:\\projects\\stud-test\\package.json","includedInParent":true,"mtime":1672313724264},{"name":"C:\\projects\\stud-test\\node_modules\\yup\\package.json","includedInParent":true,"mtime":1666601417056},{"name":"property-expr","loc":{"line":1,"column":24,"index":24},"parent":"C:\\projects\\stud-test\\node_modules\\yup\\es\\util\\reach.js","resolved":"C:\\projects\\stud-test\\node_modules\\property-expr\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getIn = getIn;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : value;\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \".concat(_part, \", in the path: \").concat(path, \". \") + \"because there is no value at that index. \");\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \".concat(path, \". \") + \"(failed at: \".concat(lastPartDebug, \" which is a type: \\\"\").concat(schema._type, \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"ed4df861f3c91c15541736e4e5e17703","cacheData":{"env":{}}}